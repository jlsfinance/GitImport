Clear and blunt: your server code is broken in multiple concrete ways and — crucially — it won’t run on Vercel the way you wrote it. Fix the code problems below and decide whether you actually want a long-running Node server (not supported by Vercel’s serverless model) or you want serverless endpoints. I’ll show exact fixes you can paste.

Biggest deployment reality you must accept
	•	Vercel is serverless. You cannot call server.listen() to run a long-lived Express process there. If you want a persistent Node server, deploy to Render, Fly, Railway, Heroku, or a VM.
	•	If you insist on Vercel, convert your Express routes into Vercel Serverless Functions (or Next.js API routes), or use their Edge Functions.

⸻

Concrete code issues (exact reasons and fixes)

1) import.meta.dirname — invalid
Problem: import.meta.dirname does not exist. That leads to distPath being wrong and your server failing to find static files.
Fix: use fileURLToPath to get directory from import.meta.url.

Patch for server/index-prod.ts (serve static):

// server/index-prod.ts
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import express from "express"; // use same import name
// ...

const __dirname = path.dirname(fileURLToPath(import.meta.url));
async function serveStatic(app, server) {
  const distPath = path.resolve(__dirname, "public"); // adjust relative path if needed
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app.use(express.static(distPath));
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}
export { serveStatic };

Action: replace import.meta.dirname usage with fileURLToPath pattern above.

⸻

2) Mixing express and express2
Problem: You imported express twice with different names. Confusing and unnecessary; could mask different versions.
Fix: Use a single import and consistent variable name across files:

import express from "express";

Delete import express2 from "express"; and use express everywhere.

⸻

3) Error handler throws after sending response — will crash the process
Problem: You res.status(...).json({message}); throw err;. Throwing after responding will kill your server (uncaught) or cause undesirable behaviour.
Fix: Log the error and do not rethrow. If you want to crash for visibility in dev, do it conditionally.

Replace:

app.use((err, _req, res, _next) => {
  const status = err.status || err.statusCode || 500;
  const message = err.message || "Internal Server Error";
  res.status(status).json({ message });
  throw err;
});

With:

app.use((err, _req, res, _next) => {
  const status = err.status || err.statusCode || 500;
  const message = err.message || "Internal Server Error";
  console.error(err);                 // log full error server-side
  if (!res.headersSent) {
    res.status(status).json({ message });
  }
  // do NOT throw; allow graceful handling
});


⸻

4) registerRoutes returns createServer(app) but you don’t actually register any routes
Problem: registerRoutes(app) doesn’t add routes — so your API endpoints may be missing. Also naming/structure unclear.
Fix: Either register routes inside that function or import proper routers. Example pattern:

// server/routes.ts
import { createServer } from "http";
import userRouter from "./routers/user.js"; // example
export async function registerRoutes(app) {
  app.use("/api/users", userRouter);
  // ... register other routers
  const httpServer = createServer(app);
  return httpServer;
}

Then in server/app.ts / index-prod.ts import the function:

import { registerRoutes } from "./routes.js";


⸻

5) Overriding res.json is risky
Problem: You replace res.json to capture JSON for logs. That can break streaming or other response types and mask this binding issues.
Fix: Use a safer wrapper that preserves this and function signature:

const originalResJson = res.json.bind(res);
res.json = function (bodyJson, ...args) {
  capturedJsonResponse = bodyJson;
  return originalResJson(bodyJson, ...args);
};


⸻

6) server.listen({ reusePort: true }) — optional but be deliberate
reusePort is fine on Linux, but be careful on some platforms. Not a show-stopper.

⸻

Full minimal corrected structure (paste-and-run)

Below is a minimal, coherent set of files you can use locally to test. Adjust paths to your project.

server/routes.ts

import { createServer } from "http";
import express from "express";
import helloRouter from "./hello-router.js"; // create this for test

export async function registerRoutes(app) {
  app.use("/api/hello", helloRouter);
  return createServer(app);
}

server/hello-router.ts

import express from "express";
const router = express.Router();
router.get("/", (_req, res) => res.json({ ok: true, msg: "hello" }));
export default router;

server/app.ts

import express from "express";

export function createApp() {
  const app = express();
  app.use(express.json());
  // Logging middleware
  app.use((req, res, next) => {
    const start = Date.now();
    const origJson = res.json.bind(res);
    let captured;
    res.json = (body) => { captured = body; return origJson(body); };
    res.on("finish", () => {
      if (req.path.startsWith("/api")) {
        const d = Date.now() - start;
        console.log(`${req.method} ${req.path} ${res.statusCode} in ${d}ms`, captured ? captured : "");
      }
    });
    next();
  });
  // Basic error handler
  app.use((err, _req, res, _next) => {
    console.error(err);
    if (!res.headersSent) res.status(err.status || 500).json({ message: err.message || "Internal Server Error" });
  });

  return app;
}

server/index-prod.ts

import { fileURLToPath } from "node:url";
import path from "node:path";
import fs from "node:fs";
import { createApp } from "./app.js";
import { registerRoutes } from "./routes.js";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

async function serveStatic(app, server) {
  const distPath = path.resolve(__dirname, "../client/public"); // adjust path
  if (!fs.existsSync(distPath)) throw new Error(`Missing dist: ${distPath}`);
  app.use(express.static(distPath));
  app.use("*", (_req, res) => res.sendFile(path.resolve(distPath, "index.html")));
}

(async () => {
  const app = createApp();
  const server = await registerRoutes(app);
  await serveStatic(app, server); // optional
  const port = parseInt(process.env.PORT || "5000", 10);
  server.listen({ port, host: "0.0.0.0" }, () => console.log(`listening on ${port}`));
})();

(Import express at top of index-prod where used.)

⸻

Local test steps (do this now)
	1.	Ensure Node >= 18 (for import esm + fileURLToPath).
	2.	Build client: cd client && npm ci && npm run build so public/index.html exists.
	3.	Run server locally:

node --experimental-specifier-resolution=node server/index-prod.js

or use a bundler/ts-node if TS.

	4.	Hit http://localhost:5000/api/hello — should return {ok:true}.

⸻

Final blunt advice & next steps (pick one)
	•	If you want to keep this as a normal Node server: stop deploying to Vercel. Use Render/Fly/Railway. Fix the code as above and deploy to one of those.
	•	If you want Vercel: convert endpoints to serverless functions or use Next.js API routes. Remove server.listen() and restructure into functions that export handlers Vercel understands.

If you want I will:
	1.	Provide a ready-to-paste single-file fix for your exact existing files (I’ll produce corrected index-prod.ts, app.ts, and routes.ts) — paste their current exact contents (I already have most of them; confirm any missing imports or file paths).
	2.	Or show how to convert one sample route to a Vercel Serverless Function.

Tell me which one: (A) full corrected Node server files to run on Render, or (B) convert to Vercel serverless function example. Don’t reply with “what” — pick A or B now.